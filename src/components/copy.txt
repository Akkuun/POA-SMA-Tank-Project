getBulletPathCurve() {
        const bodyCenterX = this._body.x;
        const bodyCenterY = this._body.y;

        //const cannonOffset = 25 * fixSize * scaleFactor;  // Distance entre le centre du tank et l'extrémité du canon
        const cannonLength = 25 * fixSize * scaleFactor;  // Longueur du canon

        // Calcule la rotation globale avec un ajustement de +PI
        let globalRotation = this._body.rotation + this._tankHead.rotation + Math.PI / 2;

        let cannonX = bodyCenterX + Math.cos(globalRotation) * cannonLength;
        let cannonY = bodyCenterY + Math.sin(globalRotation) * cannonLength;

        let path = [{startX: cannonX, startY: cannonY, endX: cannonX, endY: cannonY, rotation: globalRotation}];

        const stadiumBounds = this._gameManager._bodyStadium.getBounds();
        let lineLength = 0;
        let acumulatedLength = 0;
        let maxBounces = 3; // Nombre maximum de rebonds
        let bounces = 0;

        while (bounces < maxBounces) {
            lineLength = 0;
            let collisionDetected = false;
            let destructWallAtDistance = Infinity;
            let destructWallFunction = () => {return false;};

            // Continue à tracer la ligne jusqu'à ce qu'on touche un mur
            while (!collisionDetected) {
                lineLength += 0.5;
                acumulatedLength += 0.5;
                let endX = cannonX + Math.cos(globalRotation) * lineLength;
                let endY = cannonY + Math.sin(globalRotation) * lineLength;

                // Détection de collision avec les bords du stade
                if (endX <= stadiumBounds.x || endX >= stadiumBounds.x + stadiumBounds.width) {
                    // Rebond sur un mur vertical (gauche ou droite)
                    globalRotation = Math.PI - globalRotation; // Inversion sur l'axe X
                    collisionDetected = true;
                    cannonX = endX;
                    cannonY = endY;
                } else if (endY <= stadiumBounds.y || endY >= stadiumBounds.y + stadiumBounds.height) {
                    // Rebond sur un mur horizontal (haut ou bas)
                    globalRotation = -globalRotation; // Inversion sur l'axe Y
                    collisionDetected = true;
                    cannonX = endX;
                    cannonY = endY;
                } else {
                    for (let wall of this._gameManager._walls) {
                        if (wall.isInside(endX, endY) && !wall._destructed) {

                            if (wall.getDestruct()) {
                                destructWallAtDistance = acumulatedLength;
                                destructWallFunction = () => {
                                    if (!wall._destructed) {
                                        wall._destructed = true;
                                        this._gameManager.destructWall(wall);
                                        return true;
                                    }
                                    return false;
                                };
                            }
                            // if (wall.getDestruct()) {
                            //     path[path.length - 1].endX = endX;
                            //     path[path.length - 1].endY = endY;
                            //     if (bounces < maxBounces) {
                            //         path.push({
                            //             startX: cannonX,
                            //             startY: cannonY,
                            //             endX: cannonX,
                            //             endY: cannonY,
                            //             rotation: globalRotation,
                            //             destructWallAtSegment: true,
                            //             destructWall: () => {
                            //                 if (!wall._destructed) {
                            //                     wall._destructed = true;
                            //                     this._stadiumObject.destructWall(wall);
                            //                     return true;
                            //                 }
                            //                 return false;
                            //             }
                            //         });
                            //     }
                            //     return path;

                            // }


                            // Tester la distance jusqu'à l'espace vide le plus proche pour chaque rebond possible
                            let rotations = [Math.PI - globalRotation, -globalRotation];
                            let distances = rotations.map(rotation => this.rayCastNearestEmptySpace(endX, endY, rotation));
                            // Trouver la distance minimale, et donc la rotation correspondante
                            let minDistance = Math.min(...distances);
                            let minIndex = distances.indexOf(minDistance);
                            globalRotation = rotations[minIndex];
                            collisionDetected = true;
                            cannonX = endX;
                            cannonY = endY;
                            break;
                        }
                    }

                }
            }

            // Incrémenter le nombre de rebonds
            bounces += 1;

            path[path.length - 1].endX = cannonX;
            path[path.length - 1].endY = cannonY;
            path[path.length - 1].destructWallAtSegment = destructWallAtDistance;
            path[path.length - 1].destructWall = destructWallFunction;
            if (bounces < maxBounces) {
                path.push({
                    startX: cannonX,
                    startY: cannonY,
                    endX: cannonX,
                    endY: cannonY,
                    rotation: globalRotation
                });
            }
        }
        return path;
    }